# 02|基础篇：到底应该怎么理解“平均负载”？

## 什么是平均负载？

每次发现系统变慢时，我们通常做的第一件事，就是执行`top`或者`uptime`命令，了解系统的负载情况。如：

```shell
$ uptime   # man uptime 查看 uptime用法
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```

这里的0.63，0.83，0.88分别是过去1分钟，5分钟，15分钟的平均负载。

那么什么是平均负载（Load Average）呢？

**平均负载（Load Average）**: 单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，即**平均活跃进程数。**

**可运行状态进程**是指正在使用CPU或者是正在等待CPU的进程。即，使用`ps`命令看到的处于`R`状态(Running/Runnable)的进程。如：

```shell
kai@ubuntu:~$ ps -l
F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000   2684   2677  0  80   0 -  7375 wait   pts/2    00:00:00 bash
0 R  1000   2732   2684  0  80   0 -  8996 -      pts/2    00:00:00 ps
```

**不可中断状态的进程**是指正处于**内核态关键流程**中的进程，且这些流程是不可打断的，如最常见的等待硬件设备的I/O响应，即使用`ps`命令看到的处于`D`状态(Uninterruptible Sleep/ Disk Sleep)的进程。

如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个进程的状态就是不可中断状态。若进程此时被打断，就容易出现磁盘数据和进程数据不一致的问题。

因此，**不可中断状态实际上是系统对进程和硬件设备的一种保护机制**。

**平均活跃进程数**是指单位时间内的活跃进程数，实际上是**活跃进程数的指数衰减平均值**。

因此最理想的情况就是，每个CPU刚好运行一个进程，这样每个CPU就都得到了充分的利用，即**平均负载=CPU个数**。那么当Load Average = 2时，意味着什么？

* 在有2个CPU的系统上，意味着所有CPU都刚好被占用
* 在有4个CPU的系统上，意味着50%的CPU资源空闲。
* 在有1个CPU的系统上，意味着50%的进程竞争不到CPU。



## 平均负载为多少时合理？

最理想的状态是，平均负载=CPU个数，因此首先需要知道CPU的个数(可以从/proc/cpuinfo中读取或者`top`命令获取)：

```shell
# 从/proc/cpuinfo中读取
kai@ubuntu:~$ grep 'model name' /proc/cpuinfo
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
model name	: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz

kai@ubuntu:~$ grep 'model name' /proc/cpuinfo | wc -l
8
```

那么，当平均负载>CPU个数的时候，就知道系统过载了。

但是，平均负载有个3个值，到底应该看哪个值呢？

答案是，都得看。三个不同时间间隔的平均值，提供了分析**系统负载趋势**的数据，让我们更加全面、立体地理解目前的负载状况。

* 若1分钟，5分钟，15分钟的平均负载值基本相同或者差别不大，则说明系统负载很平稳。
* 若1分钟的值远小于15分钟的值，说明系统最近1分钟的负载在减少，而过去15分钟内却有很大的负载。
* 反之，则说明最近1分钟内的负载在增加，可能是暂时的，也可能会持续增加，这就需要持续分析了。一旦1分钟的平均负载接近或者超过了CPU的个数，就意味着系统正在发生过载问题，就需要分析问题，优化系统负载的使用了。

例如，一个单CPU系统上，平均负载分别为：1.73，0.6，7.98，说明在过去的1分钟内，系统有73%的超载，而在15分钟内，则有698%的超载，整体来看，系统负载在降低。

那么，实际生产环境中，平均负载是多少时，我们需要重点关注呢？

当**平均负载高出CPU数量的70%**的时候，就应该分析排查负载高的问题了。一旦负载过高，就会导致进程响应变慢，进而影响服务的正常功能。

但是70%并不是绝对的，想要获得更加合理的数据，应该将系统的平均负载监控起来，然后根据更多的历史数据全面的判断负载变化趋势。当发现负载有明显的升高趋势时，再分析调查。



## 平均负载与CPU使用率

平均负载并不等于CPU使用率，为什么呢？

平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。这些进程包括**正在使用CPU的进程**、**等待使用CPU的进程**以及**等待I/O**的进程。

CPU使用率是指单位时间内，CPU的使用情况的统计，这一点与平均负载所述的情况并不完全对应。

那么，平均负载与CPU使用率有什么关系呢？

* CPU密集型进程，使用大量CPU会导致平均负载升高，因此二者的变化情况一致。
* I/O密集型进程，等待I/O会导致平均负载升高，而CPU使用率未必高。
* 大量等待CPU的进程调度也会导致平均负载提高，此时CPU使用率也会比较高。



## 小结

平均负载反映了系统整体的负载情况，体现了系统的整体性能。

平均负载的升高，可能是因为：

* CPU密集型进程导致的，从这个意义上说，平均负载与CPU使用率一致。
* 也可能是因为I/O更加频繁，从这个意义上说，平均负载与CPU使用率不是等价的。

当负载升高的时候，可以使用mpstat、pidstat等工具，分析平均负载的来源。







