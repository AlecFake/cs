# MySQL数据库系列之事务

## 1.事务

**事务(transaction)** 是指一组数据库操作，要么全部成功，要么全部失败。

以“A账户向B账户转账100元”这个转账操作为例说明。A账户要给B账户转账，需要经历以下步骤：

* 1.读取A账户余额；
* 2.将A账户余额减去100元；
* 3.更新A账户余额；
* 4.读取B账户余额；
* 5.将B账户余额加100元；
* 6.更新B账户余额。

为了保证数据的一致性，这一组操作（以上的6个操作）要么全部完成，要么全部失败。这就是事务。

本文将探讨MySQL数据库的事务特性。MySQL数据库主要包括Server层和引擎层，MySQL的事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，但是并不是说所有的引擎都支持事务。例如，MySQL原生的MyISAM引擎就不支持事务，而InnoDB则支持事务，因此在MySQL数据库中，InnoDB取代了MyISAM，成为默认的存储引擎。

## 2.事务的四个特性

数据库管理系统（DBMS）在写入或者更新资料的过程中，为了保证事务是正确可靠的，必须具备四个特性（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

### 2.1 原子性

**原子性**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中，若发生错误，则会回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即事务不可分割、不可约简。

例如，“A账户向B账户转账100元”这个事务的6个操作必须要么全部执行要么全部不执行，才满足原子性。

### 2.2 一致性

**一致性**：在事务开始之前和事务执行结束以后，数据库的完整性没有被破坏。

例如，以转账为例，假如A账户和B账户的余额总共为1000，那么不论A和B之间转账多少次，最终所有转账事务结束之后，二者余额相加仍然应该是1000。这就是事务的一致性。

### 2.3 隔离性

**隔离性**：数据库允许多个并发事务同时对数据库进行读写和修改，多个并发事务之间相互隔离，互不干扰。

例如，给定任意2个并发事务T1和T2，在事务T1看来，T2要么在T1开始之前已经结束，要么在T1结束之后才才能开始，事务之间感觉不到其它的事务在并发地执行，但是事实上确实是在并发执行。

### 2.4 持久性

**持久性**：事务一旦提交，对数据库中的数据的修改就是永久性的，即使系统故障，此修改也不会消失。

## 3.事务的隔离性与隔离级别

下面重点讨论一下事务的隔离性，事务的隔离性特性主要是应对并发事务可能出现的问题。

### 3.1 读现象

当数据库上有多个事务并发执行的时候，可能出现脏读（dirty read）、不可重复读（non repeated read）以及幻读（phantom read）。

#### 3.1.1 脏读

**脏读**：事务正在多次修改某个数据的时候，而这个事务中多次的修改都未提交，若此时另外一个并发的事务读取该数据，就会造成2个事务得到的数据不一致。

例如，A账户向B账户转账100元。SQL命令如下：

```sql
update account set money=money+100 where name='B'; // 此时A通知B
update account set money=money-100 where name='A';
```

当只执行第一条SQL语句时，A账户转账100元这个事务（转账事务）并未提交，此时A用户通知B用户查看账户（查询事务），B用户发现钱已经到账（此时发生了脏读），那么无论第二条语句是否执行，只要该事务不提交，则所有操作都要回滚，B用户再次查看账户时就会发现钱其实并没有转。

#### 3.1.2 不可重复读

**不可重复读（non repeated read）**：对于数据库中的某个数据，在同一个事务中，多次读取这个数据，发现返回的是不同的值。这是因为在查询间隔，这个数据已经被其他事务修改并且**提交**了。

例如，事务T1在读取某个数据的时候，事务T2修改了该数据，并且提交给了数据库，事务T1再次读取该数据的时候，就得到了不同的结果，此时就发生了不可重复读。

**不可重复读与脏读的区别在于**，前者读取了另外一个事务提交的数据，后者读取了另外一个事务未提交的数据。

#### 3.1.3 幻读

**幻读**：在同一个事务中，同一个查询多次返回的结果不一致。

例如，事务T1执行了一次查询操作，事务T2新增了一条记录并且提交，然后事务T1又一次执行了一次查询操作，然后提交。那么事务T1执行的2次查询操作得到的结果是不一致的。

为了解决以上三个问题，就有了“隔离级别”的概念。以下讨论隔离级别。

### 3.2 事务的隔离级别

SQL标准的隔离级别按照隔离程度从低到高依次为：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

**1.读未提交**：一个事务未提交时，该事务所作的修改就能被其他事务看到。这是最低的隔离水平，**脏读、不可重复读以及幻读都可能出现。**

**2.读提交**：一个事务提交之后，该事务所作的修改才能被其他事务看到。也就是不会看到任何中间状态，因此**不会出现脏读**。但是此级别并不能保证再次读取时能够获得同样的数据或者再次查询时获得同样结果，即允许其他事务并发修改数据，**允许不可重复读和幻读出现**。因此，**此隔离级别避免脏读出现**。

**3.可重复读**：一个事务执行过程中看到的数据，始终和这个事务启动时看到的数据是一致的。**此隔离级别可以避免脏读、不可重复读的出现**。（注：这是MySQL InnoDB引擎默认的隔离级别）

**4.串行化**：对于同一行记录，读数据的时候，会加共享读锁，写数据的时候会加排他写锁，。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。**此隔离级别可以避免脏读、不可重复读以及幻读的出现。**

在不同的隔离级别下，数据库行为是不同的。Oracle数据库的默认隔离级别是**读提交**，MySQL数据库InnoDB引擎默认的隔离级别是**可重复读**，因此对于一些从Oracle迁移到 MySQL的应用，为了保证隔离级别的一致，应该修改MySQL的隔离级别为 **读提交**。

设置的方式是：将启动参数transaction-isolation的值设置为READ-COMMITTED，注意这个修改必须要在开启事务之前。

在这里要说一下，可重复读这个隔离级别的应用场景：数据校对。

假设你在管理一个个人银行账目表。一个表存储了每个月月底的余额，一个表存了账单明细。此时，需要判断上个月的余额和当前余额的差额是否与本月账单明细一致。那么在校对的过程中，就希望即使这个用户发生了一笔新交易，那么也不会影响校对的结果。

在数据校对中，可重复读隔离级别就很好用。因为此时该事务的数据从头到尾都是一致的，不受其他事务更新的影响。

### 3.3 事务隔离的实现

那么事务隔离是如何实现的呢？

对于读未提交隔离级别来说，直接返回数据的最新值。对于读提交和可重复读隔离级别来说，数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。对于读提交隔离级别而言，这个视图是在每个SQL语句开始执行的时候创建的，而对可重复读隔离级别而言，视图则是则是在启动时创建的，整个事务存在期间都在用这个视图。对于串行化隔离级别来说，直接使用加锁的方式来避免并行访问。

接下来以可重复读隔离级别为例，深入的说明一下。

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录的最新值，通过回滚操作，都可以得到前一个状态的值。

若一个值从1被顺序修改成了2,3,4，那么回滚日志就会有类似下面的记录。

当前值为4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的视图（read-view）。如图所示，同一个记录，在不同的视图中，值也不同。对于read-view A，要想得到1，就必须将当前值依次执行图中的回滚过程，即4-3-2-1。同时，即使有另外一个事务正在将4修改为5，这个事务和read-view A，B，C对应的事务是不会冲突的，这就是可重复读的实现。

**多版本并发控制**（MVCC，Multi-Versioning Concurrency Control）：同一条记录在系统中可以存在多个版本。上述的对于同一个数据，不同视图中不同值的现象就是MVCC。

那么回滚日志什么时候删除呢？在不需要的时候删除。当系统判断系统中没有事务会再用这些回滚日志的时候，就会被删除。那么什么时候才不需要呢? 当系统里没有比这个回滚日志更早的read-view的时候。

以下讨论一下，为什么尽量不要使用长事务？

长事务表明系统中存在很老的事务视图。由于这些事务随时可能访问数据库的任何数据，因此这些事务提交之前，数据库中涉及到它可能访问的回滚记录都需要保留，这就会占用大量的存储空间。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

因此，长事务存在潜在的风险，应该尽量避免使用。

## 4. 思考题

既然长事务存在潜在的风险，那么如何用正确的方式避免长事务呢？



## 参考文献

[1] https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels

[2] https://time.geekbang.org/column/article/68963











